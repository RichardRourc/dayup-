
DFS（Depth-First Search）

针对图或者树的数据结构，对节点进行根据顶节点到子节点遍历完再返回邻节点依次遍历，说人话就是一层层的挖下去。

常见实现方式有递归和栈。

假设树的结构是一个对象，且有value和children两个属性，分别代表当前值和子数组。

```js
    class TreeNode {
        constructor(val) {
            this.value = val;
            this.children = [];
        }

        addChild(child){
            this.children.push(child)
        }
    }

    // 示例树
    const root = new TreeNode('A');
    const B = new TreeNode('B');
    const C = new TreeNode('C');
    const D = new TreeNode('D');
    const E = new TreeNode('E');

    root.addChild(b);
    root.addChild(c);
    b.addChild(d);
    b.addChild(e);

    // 调用深度优先遍历
    dfs(root);

    // 输出
    A
    B
    D
    E
    C
```


递归

```js
    function dfs(root){
        if(!root) return;

        // 访问当前节点
        console.log(root.value);

        // 遍历所有子节点
        for(const child of root.children) {
            dfs(child)
        }
    }
```

使用栈

```js
    function dfs(root) {
        if(!root) return;
        const stack = [root]
        
        // 用栈去不断循环。
        while(stack.length>0) {
            let node = stack.pop();

            console.log(node.value);

            // 倒序添加子节点，方便栈操作，最后进的最后出，达到深度遍历的效果
            for(let i = node.children.length-1;i>=0;i--) {
                stack.push(node.children[i]);
            }
        }
    }
```

时间复杂度
O(n)，n是每个树节点的数量，因为每个节点都会被访问一次。

空间复杂度
O(h)，h是树的高度，因为递归栈的最大深度是树的高度。